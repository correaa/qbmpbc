#ifdef compile_instructions
ln -sf $0 $0.cpp && c++ `#-std=c++0x` -Wall -Wextra `#-Wfatal-errors` -Wno-unused-variable -Wno-unused-parameter -Wno-ignored-qualifiers -lhunspell -I$HOME/usr/include -I$HOME/prj $0.cpp -Wl,-rpath=$HOME/usr/lib -L$HOME/usr/lib  -lboost_regex -lboost_system -lboost_filesystem  -D_TEST_LATEX_HPP -o ./$0.x && ./$0.x $@ && (evince latex.pdf&)
rm -rf $0.cpp $0.x
exit
#endif
#ifndef LATEX_HPP
#define LATEX_HPP
#include<string>
#include<sstream>
#include<vector>
#include<boost/filesystem/fstream.hpp>
#include<boost/filesystem/convenience.hpp>
#include<boost/format.hpp>
#include<map>
#include<set>
#include<complex>
#include<iostream> //clog
#include<boost/lexical_cast.hpp>
#include<boost/tuple/tuple.hpp>
#include<boost/regex.hpp>
#include"boost/named.hpp"
#include<iomanip>
#include<boost/math/special_functions/fpclassify.hpp> //(boost::math::isinf)
#include <boost/algorithm/string.hpp> // boost::replace_last
#include<map>
#include<boost/numeric/interval.hpp>
#include<boost/multi_array.hpp>
#include<boost/process.hpp>
#include<boost/algorithm/string/classification.hpp>
#include<boost/algorithm/string/split.hpp>
#include<boost/logic/tribool.hpp>
#include<boost/tokenizer.hpp>
#include "alf/hunspell.hpp" // needs -lhunspell
using boost::lexical_cast;

#ifndef LATEX_UNITS_HPP
#define LATEX_UNITS_HPP
#include<boost/units/quantity.hpp>
#include<boost/units/physical_dimensions.hpp>
namespace boost{
namespace units{
using std::string;
template<class Dimension> string name                 (){return "";}

template<> string name<energy_dimension              >(){return "Energy";}
template<> string name<force_dimension               >(){return "Force";}
template<> string name<velocity_dimension            >(){return "Velocity";}
template<> string name<volume_dimension              >(){return "Volume";}
template<> string name<length_dimension              >(){return "Length";}
template<> string name<pressure_dimension            >(){return "Pressure";}
template<> string name<temperature_dimension         >(){return "Temperature";}
template<> string name<heat_capacity_dimension       >(){return "Entropy";}
template<> string name<time_dimension                >(){return "Time";}
template<> string name<mass_density_dimension        >(){return "Mass Density";}
template<> string name<thermal_conductivity_dimension>(){return "Thermal Conductivity";}
template<> string name<wavenumber_dimension          >(){return "Wavenumber";}
template<> string name<
	derived_dimension<
		length_base_dimension,  -3,
		time_base_dimension,     1,
		current_base_dimension,  1
	>::type
>(){return "Charge Density";}

}}

namespace boost{
namespace units{
using std::string;
inline string latexify(string const& units_s){
	using namespace boost;
	std::string ret = units_s;
	ret=regex_replace(ret,
		regex("\\^\\(*([+,-]*\\d{1,}/*\\d{0,})\\)*", boost::regex::perl),
		"^{$1}"
	);
	ret=regex_replace(ret,
		regex("(\\s)", regex::perl),
		"\\\\, "
	);
	boost::regex subscripts("_(\\w+)", boost::regex::icase|boost::regex::perl);	
	ret=regex_replace(ret,subscripts,"_{\\\\rm $1}");
	return /*"\\mathrm{"+*/ ret /*+"}"*/
	;
}

/// Transforms usual Boost unit symbol_string into usual LaTeX output
template<class Dimension, class System>
inline std::string latex_string(unit<Dimension, System> const& r){
	return latexify(symbol_string(r));
}

template<class System>
inline std::string latex_string(unit<dimensionless_type, System> const&){
	return "";
}

}}

#include<boost/units/systems/si.hpp>
#include"boost/units/systems/atomic.hpp"
namespace boost{
namespace units{
namespace si{
//template<class Unit>
std::string latex_string(si::femto_scaled<si::time>::unit const&){
	return "\\ensuremath{\\rm{fs}}"; //+latex_string(si::time());
}
}}}
namespace boost{
namespace units{

using std::string;
template<> string name<atomic::wavefunction_amplitude::dimension_type>(){return "Wavefunction Amplitude";}

namespace si{
template<class Dimension>
inline std::string latex_string(unit<Dimension, si::system> const& r){
	return "\\rm{"+latexify(symbol_string(r))+"}";
}
inline std::string latex_string(unit<dimensionless_type, si::system> const&){
	return "";
}
}}}
#include<boost/units/systems/cgs.hpp>
namespace boost{
namespace units{
namespace cgs{
template<class Dimension>
inline std::string latex_string(unit<Dimension, cgs::system> const& r){
	return "\\rm{"+latexify(symbol_string(r))+"}";
}
}}}


namespace boost{
namespace units{
namespace nonsi{
std::string latex_string(nonsi::electron_volt_unit const&){
	return "\\ensuremath{\\rm{eV}}";
}
}}}
#endif

/// Automatic generation of LaTeX code for output
namespace latex{
	using std::string;
	using std::endl;
	using std::clog;
	using namespace boost::filesystem;
	using namespace boost::units;
	struct ostream;
	struct language : virtual std::string{
		language(){}
		language(std::string const& s) : std::string(s){}
		virtual void operator>>(ostream& os) const;
	};
	struct english : language{
		english(std::string const& s) : std::string(s){}
		virtual void operator>>(ostream& os) const;
	};
	struct error : std::runtime_error{
		error(std::string const& what) : std::runtime_error(what){}
	};
	struct undefined_control_sequence : error{
		undefined_control_sequence(std::string const& what) : error(what){}
	};
	class document{};
	class article : document{};
	static std::map<void*, std::string> name;
	struct environment;
	/// LaTeX (or indirect PDF) output stream, it can feed from specific LaTeX object of from strings with LaTeX code
	struct ostream : protected std::ostringstream{
		static std::map<string, string> unicode_translation;
		protected:
		using std::ostringstream::str;
		public:
		std::set<path> temp_files_;
		std::set<string> packages_;
		std::map<string, string> fields_;
		string title;
		string author;
		std::ostringstream preamble_;
		typedef std::ostringstream base;
		path p_;
		ostream(){}
		ostream(path const& p) : p_(p) {};

		friend ostream& operator<<(ostream& os, bool   const& b){
			if(b==true){
				((base&)(os))<< "\\ding{51}"; // pifont::ding{51} // amsmath::checked unicode::2713 âœ“ 
			}else{
				((base&)(os))<< "\\ding{55}"; // ding: pifont package unicode::2717 âœ—
			}
			 return os;
		}
		
		friend ostream& operator<<(ostream& os, boost::logic::tribool const& tb){
			if(tb){
				((base&)(os))<< "\\mvchr{86}"; // marvosym::Checkedbox pifont::CheckedBox  unicode::2611 ballot box with check â˜‘
			}else if(!tb){
				((base&)(os))<< "\\mvchr{88}"; // marvosym::Crossedbox pifont::XBox unicode::2612 ballot box with x â˜’
			}else{
				((base&)(os))<< "\\mvchr{79}"; //"\\Square"; //  pifont::Square unicode: 2610 ballot box â˜
			}
			return os;
		}
		friend ostream& operator<<(ostream& os, int      const& s){((base&)(os))<< s; return os;}
		friend ostream& operator<<(ostream& os, unsigned const& s){((base&)(os))<< s; return os;}
		friend ostream& operator<<(ostream& os, double const& d); 
		friend ostream& operator<<(ostream& os, string const& s){
			((base&)(os))<< s; return os;
		}
		friend ostream& operator<<(ostream& os, language const& l){ l >> os; return os; };
		friend ostream& operator<<(ostream& os, const char* const c){os<<string(c); return os;}
		friend ostream& operator<<(ostream& os, boost::filesystem::path const& p){os<<"\\url{file:" << p.string() << "}";return os;}
		friend ostream& operator<<(ostream& os, environment const& env);
		template<class Unit>
		friend ostream& operator<<(ostream& os, boost::units::quantity<Unit> const& q);
		~ostream(){
			flush(*this);
			for(std::set<path>::iterator it=temp_files_.begin(); it!=temp_files_.end(); ++it){
				clog << "please delete 'rm " << it->string() << "'" << std::endl;
				//boost::filesystem::remove(*it);
			}
		}
		void declare_unicode_character(string const& code, string const& symbol){
			preamble() << ("\\DeclareUnicodeCharacter{\""+ code +"}{"+ symbol +"}\n");
		}
		static ostream& flush(ostream& os){
			std::clog << "generating " << os.p_.string() << std::endl;
			//std::string test_line = "! LaTeX Error: File `aaa.tex' not found.";
			//boost::regex file_not_found("LaTeX Error File `(.*)' not found");//("! LaTeX Error: File `(.*)' not found.");
			
			(base&)os<<std::flush;
			if(os.p_==path("")) return os;
			path p_tex;
			path p_pdf;
			if(os.p_.extension()==".tex"){
				p_tex = os.p_;
			}else if(os.p_.extension()==".pdf"){ // note: latex auxiliary files can't be invisible
				p_tex = os.p_.stem() + ".tex"; //.string()
			}else{ //< possibly add dvi and ps, dvi to text also is interesting
				throw std::runtime_error("do not know what to do with given extension for LaTeX output"); //"+os.p_.extension() +" .string() 
			}
			{
				boost::filesystem::ofstream ofs(p_tex);
				ofs << "\\documentclass[12pt,fleqn]{tufte-handout}\n"; //{article}\n";
				ofs << "\\usepackage["
					<< "compatibility=off, "
					<< "font={small}]{caption}\n"; //for caption* (not numbered), compatibility=off to ensure this
				//ofs <<
					//"\\usepackage["
					//"mathletters"// autogenerated" //, postscript"
					//"]{ucs}\n"; // âˆ‚â„âºâ»Â±â„‘â‚Šâ„‹â‚‹â„«âˆ‘Ï‰Î¼âŒ©âŒªÂ³Â²Â½
				ofs << "\\usepackage["
					<< "utf8x"
					<< "]{inputenc}\n";
				ofs << "\\usepackage{mathrsfs}\n"; // for mathscr
				//ofs << "\\usepackage{cool}\n";
				ofs << "\\usepackage{listings}\n";
				ofs << "\\usepackage{xcolor}\n";   //included in tufte-latex but useful to convert document to plain article
				ofs << "\\usepackage{geometry}\n"; //idem 
				ofs << 
					"\\definecolor{darkgray}{rgb}{0.95,0.95,0.95}\n "
					"\\lstset{language={[GNU]C++}}\n "
					"\\lstset{backgroundcolor=\\color{darkgray}}\n"
					"\\lstset{numbers=left, numberstyle=\\tiny, stepnumber=2, numbersep=5pt}\n"
					//"\\lstset{keywordstyle=\\color{red}\\bfseries\\emph}\n"
				;
				ofs <<"\\hypersetup{pdfencoding=unicode}\n"; //hyperref options set in w/hypersetup because tufte loads hyperref
				// ofs << "\\usepackage[pdfborder={0 0 0}, pagebackref=true]{hyperref}\n"; //not compatible with tufte-*
				// ofs<<"\\usepackage{courier}\n"; //look like ms courier 
				ofs << "\\newcommand{\\unicodesub}[1]{_{#1}}\n"; // â‚€
				ofs << "\\newcommand{\\unicodewide}[1]{#1}\n";
				//ofs << "\\newcommand{\\unicodesuper}[1]{^{#1}}\n";
				os.declare_unicode_character("00B2", "^2");                                       // Â²
				ofs << "\\DeclareUnicodeCharacter{\"BD}{\\ensuremath{\\text{\\textonehalf}}}\n";   // Â½
				ofs << "\\DeclareUnicodeCharacter{\"035D}{\\ensuremath{\\phi}} \n";                // ðœÂ™  math phi
				os.declare_unicode_character("03B1", "\\alpha");                                   // Î± theta, sometimes translated as \texttheta, result of copying from pdf avoids ! LaTeX Error: Command \textalpha unavailable in encoding T1.
				os.declare_unicode_character("03B2", "\\beta");                                    // Î² theta, sometimes translated as \texttheta, result of copying from pdf avoids ! LaTeX Error: Command \textalpha unavailable in encoding T1.		
				os.declare_unicode_character("03B8", "\\theta");                                   // Î¸ theta, sometimes translated as \texttheta, result of copying from pdf avoids ! LaTeX Error: Command \textalpha unavailable in encoding T1.
				ofs << "\\DeclareUnicodeCharacter{\"212B}{\\mathrm{\\mathring{A}}} \n";            // â„« \\ensuremath{\\rm{\\AA}}
				ofs << "\\DeclareUnicodeCharacter{\"2329}{\\ensuremath{\\langle}}\n";              // âŒ©
				ofs << "\\DeclareUnicodeCharacter{\"232A}{\\ensuremath{\\rangle}}\n";              // âŒª
				ofs << "\\DeclareUnicodeCharacter{\"1D62}{\\ensuremath{_i}}\n";                    // â±¼ 
				ofs << "\\DeclareUnicodeCharacter{\"2044}{\\over}\n";                              // â„ fraction slash
				ofs << "\\DeclareUnicodeCharacter{\"2C7C}{\\ensuremath{_j}}\n";                    // â±¼ 
				ofs << "\\DeclareUnicodeCharacter{\"2148}{\\unichar{105}}\n";                      //
				ofs << "\\DeclareUnicodeCharacter{\"1D4E9}{\\ensuremath{\\mathcal{Z}}}\n";         // â±¼ 
				ofs << "\\DeclareUnicodeCharacter{\"1D4D4}{\\ensuremath{\\mathcal{E}}}\n";         // â±¼ 
				ofs << "\\DeclareUnicodeCharacter{\"1D4D4}{\\ensuremath{\\mathcal{E}}}\n";         // â±¼ 
				os.declare_unicode_character("1D609", "_\\text{B}");                                // ð˜Â‰
				os.declare_unicode_character("1D624", "_\\text{c}");                               // ð˜¤
				os.declare_unicode_character("1D6FA", "\\Omega");                                  // ð›º
				os.declare_unicode_character("1D6FD", "\\beta");                                  // ð›½
				os.declare_unicode_character("1D707", "\\mu");                                     // ðœÂ‡
				os.declare_unicode_character("1D70E", "\\sigma");
				os.declare_unicode_character("1D708", "\\nu");                               // ðœÂˆ
				ofs << "\\DeclareUnicodeCharacter{\"2192}{\\ensuremath{\\rightarrow}}\n";          // â†’ rightwards arrow
				ofs << "\\DeclareUnicodeCharacter{\"2799}{\\ensuremath{\\to}}\n";                  // âž™ rightwards arrow
				ofs << "\\DeclareUnicodeCharacter{\"27F6}{\\ensuremath{\\longrightarrow}}\n";      // â±¼ 
				ofs << "\\DeclareUnicodeCharacter{\"2423}{\\ensuremath{\\quad}}\n";                // â£ open box graphic for space
				ofs << "\\DeclareUnicodeCharacter{\"FF08}{\\bigg(}\n";                             // ï¼ˆ open wide parethesis
				ofs << "\\DeclareUnicodeCharacter{\"FF09}{\\bigg)}\n";                             // ï¼ˆ close wide parethesis
				ofs << "\\DeclareUnicodeCharacter{\"FF5B}{\\left\\{}\n";                           // ï½› open wide curly bracket
				ofs << "\\DeclareUnicodeCharacter{\"FF5D}{\\right\\}}\n";                          // ï½ close wide curly bracket
				ofs << "\\DeclareUnicodeCharacter{\"FFFD}{\\ensuremath{\\mathcal{E}}}\n";          //
				ofs << "\\DeclareUnicodeCharacter{\"1D700}{\\ensuremath{\\varepsilon}}\n";         //
				ofs << "\\DeclareUnicodeCharacter{\"1D714}{\\ensuremath{\\omega}}\n";              //
				ofs << "\\DeclareUnicodeCharacter{\"1D70B}{\\ensuremath{\\pi}}\n";                 //
				ofs << "\\usepackage{amsmath}\n"; //for begin{cases}
				ofs << "\\usepackage{marvosym}\n"; //for checkedbox etc
				ofs << "\\usepackage{wasysym}\n";
				ofs << "\\usepackage{pifont}\n";
				ofs << "\\usepackage{bbold}\n"; //bbold for mathbb
				ofs << "\\usepackage{textcomp}\n"; //for capitalring
				ofs << "\\usepackage{color}\n";
				//ofs << "\\usepackage[left=1cm, right=1cm, top=1.7cm, bottom=1.7cm]{geometry}\n"; //not compatible with tufte-*
				//ofs << "\\geometry{left=1.5cm, right=10cm, marginparwidth = 7cm}\n"; //right=1cm, top=1.7cm, bottom=1.7cm
				ofs << "\\geometry{left=1.1cm, right=8.5cm, marginparwidth = 6.5cm}\n"; //right=1cm, top=1.7cm, bottom=1.7cm
				// include pdfcomment  (pdf annotations), savesymbol used to make it compatible with tufte-latex!
				ofs << 
					"\\usepackage{savesym}\n"
					"\\savesymbol{marginnote}\n"
					"\\usepackage{pdfcomment}\n"
					"\\restoresymbol{pdfcomm}{marginnote}\n"
				;
				//ofs << "\\usepackage{pdfcomment}\n"; //not compatible with tufte-* important
				ofs << "\\usepackage[]{attachfile2}\n";
				ofs << "\\usepackage[]{pdfmarginpar}\n";
				ofs << "\\pdfstringdefDisableCommands{%\n";
				ofs << "     \\let\\n\\textLF\n";
				ofs << " }\n"; //to allow linebreaks in pdf-comments
				for(std::set<string>::const_iterator it=os.packages_.begin(); it!=os.packages_.end(); ++it){
					ofs<<"\\usepackage{"<<*it<<"}\n";
				}
				ofs<<os.preamble().str()<<"\n";
				//ofs << "\\usepackage[active,tightpage]{preview}\n"
				//	"\\PreviewEnvironment{tikzpicture}\n";
				//ofs<<"\\usepackage{cmbright}\n";
				//ofs<<"\\usepackage[math]{iwona}\n";
				//ofs<<"\\usepackage[math]{anttor}\n";
				//ofs<<"\\usepackage{pxfonts}\n"; //ofs<<"\\usepackage{mathpazo}\n"; //ofs<<"\\usepackage{mathpple}\n";
				//ofs<<"\\usepackage[varg]{txfonts}\n"; //\usepackage{mathtime} //\usepackage{mathptmx} //\usepackage{mbtimes} //times like
				//ofs<<"\\usepackage{arev}\n"; // blocky
				//ofs<<"\\usepackage[charter]{mathdesign}\n"; //very nice
				//ofs<<"\\usepackage{fourier}\n"; //nice
				//ofs<<"\\renewcommand{\\rmdefault}{cmss}\n";
				//ofs<<"\\usepackage[firstpage]{draftwatermark}\n\\SetWatermarkLightness{ 0.95 }\n\\SetWatermarkScale{ 5 }\n"; //can't use this because it doesn't work in single page documents
				string watermark ; //= "DRAFT";
				ofs<<
					"\\usepackage{graphicx}\n"
					"\\usepackage{type1cm}\n"
					"\\usepackage{eso-pic}\n" //for watermark, other packages fail to put a water mark in the last page
					"\\usepackage{color}\n"
					"\\makeatletter\n"
					"\\AddToShipoutPicture{%\n"
					"   \\setlength{\\@tempdimb}{.5\\paperwidth}%\n"
					"   \\setlength{\\@tempdimc}{.5\\paperheight}%\n"
					"   \\setlength{\\unitlength}{1pt}%\n"
					"   \\put(\\strip@pt\\@tempdimb,\\strip@pt\\@tempdimc){%\n"
					"	\\makebox(0,0){\\rotatebox{45}{\\textcolor[gray]{0.95}%\n"
					"	{\\fontsize{6cm}{6cm}\\selectfont{" + watermark + "}}}}%\n"
					"}%\n"
					"}\n"
					"\\makeatother";
				//ofs << "\\usepackage{natbib}\n";
				//ofs << "\\bibliographystyle{plainnat}\n";
				ofs << "\\usepackage{backref}\n";
				ofs << "\\usepackage{lastpage}\n";
				ofs << "\\usepackage{fancyhdr}\n\\setlength{\\headheight}{15.2pt}\n\\pagestyle{fancy}\n";
				ofs << "\\usepackage{datetime} \\ddmmyyyydate\n"; //{\\color{gray}{\\currenttime}}~ \\usdate
				//ofs << "\\lfoot{Alfredo Correa \\href{mailto:correaa@llnl.gov}{\\nolinkurl{<correaa@llnl.gov>}}}\n\\cfoot{\\thepage \\color{gray}{/\\pageref{LastPage}}}\n\\rfoot{\\today~\\color{gray}{\\currenttime}}\n"; //\\color{gray}
				//ofs << "\\renewcommand{\\headrulewidth}{0.0pt}\n\\renewcommand{\\footrulewidth}{0.4pt}\n";
				ofs << "%\\usepgfplotslibrary{external}\n"
					  "%\\tikzexternalize% activate externalization!\n";
				ofs << "\\widowpenalty=10000\n"; //up to 10000 from http://en.wikibooks.org/wiki/LaTeX/Page_Layout#Widows_and_orphans
				ofs << "\\clubpenalty=10000\n"; //up to 10000  or from http://xpt.sourceforge.net/techdocs/language/latex/latex35-OrphanSpaceControl/ar01s04.html
				ofs << "\\setlength{\\parskip}{3ex plus 2ex minus 2ex}\n"; //rubber band between paragraphs
				if(os.title!="") ofs<<"\\title{"<<os.title<<"}\n";
				if(os.title!="") ofs<<"\\author{"<<os.author<<"}\n";
				ofs <<
					"\\begin{document}\n"
						<< os.str() << "\n\n"
					"\\end{document}\n"
				;
			}
			if(os.p_.extension()==".pdf"){
				clog << "generating "<< p_tex.string() << " ... "<< std::endl;
				std::string exec = boost::process::find_executable_in_path("pdflatex"); //"pdflatex"; 
				std::vector<std::string> args; 
				args.push_back(exec);
				args.push_back("-shell-escape"); 
				//args.push_back("-interaction");
				//args.push_back("nonstopmode"); //("batchmode");
				//args.push_back("-halt-on-error");
				args.push_back(p_tex.string());
				boost::process::context ctx;
				ctx.environment = boost::process::self::get_environment();
				ctx.stdin_behavior = boost::process::capture_stream();
				ctx.stdout_behavior = boost::process::capture_stream();//boost::process::silence_stream();
				for(unsigned i=0; i<2; ++i){
					boost::process::child c = boost::process::launch(exec, args, ctx); 
					boost::process::pistream &is = c.get_stdout();
					boost::process::postream &os = c.get_stdin();
					std::string line;
					std::string error_type;
					std::string error_context;
					while (std::getline(is, line)){
						if(line[0]=='!'){   
							error_type=line;
							clog << "warning: LaTeX error " << error_type <<  " found" << std::endl;
							{
								//std::string test_line = "! LaTeX Error: File `aaa.tex' not found.";
								//boost::regex test_rx("! LaTeX Error: File `aaa.tex' not found.");
								//std::clog << boost::regex_replace(test_line, test_rx, "$1");
							}
							if(error_type=="! Undefined control sequence."){
								std::getline(is, error_context);
								std::vector<std::string> v;
								boost::algorithm::split(v, error_context, boost::algorithm::is_any_of(" "));
								std::clog << "error in " << p_tex.string() <<" : undefined " << v[v.size()-2] << std::endl;
								os  
									<< "I{\\color{red}\\verb+" 
									<< v[v.size()-2]
									<< "+}" << std::endl
								;
							//}else if(boost::regex_match(error_type, file_not_found)){
							//	{std::ofstream ofs("missing.tex"); ofs << "{\\color{red}\\verb+<missing file>+}" << std::endl;}
							//	clog << "warning: file not found "<< error_type << std::endl; 
							//	os << "missing.tex" << std::endl;
							}else{
								std::string error_inserted;
								std::getline(is, error_inserted);
								std::clog << "error in "<< p_tex.string() <<" : inserted " << error_inserted << std::endl;
								os << " " << std::endl //ignore error
								;
							}
						}
					}
				}//for
			}
			std::clog << "generated " << os.p_.string() << std::endl;
			return os;
		}
		ostream& usepackage(string const& s){packages_.insert(s); return *this;}
		static ostream& endl(ostream& os){
			//os<<"\n\n"; 
			//return flush(os);
			return flush(os<<"\n\n");
		}
		std::ostringstream& preamble(){return preamble_;}
		string preamble() const{return preamble_.str();}
		typedef std::ostream&(*std_manipulator)(std::ostream&);
		ostream& operator<<(std_manipulator manip){
			if(manip==(std::ostream& (*)(std::ostream&))std::endl){ // need cast due to some overload
				return ostream::endl(*this); //this can avoid lots of confusion
			}
			if(manip==(std::ostream& (*)(std::ostream&))std::flush){
				return ostream::flush(*this);
			}
			return *this;
		}
	};
	void language::operator>>(ostream& os) const{
		os << (std::string const&)(*this);
	}
	void english::operator>>(ostream& os) const{
		std::string corrected(*this);
		typedef boost::tokenizer<boost::char_separator<char> > tokenizer; 
		tokenizer tok(*this, boost::char_separator<char>(" .,;:[]~!@#$%^&*()_+=-`\"\'?<>/")); 
		hunspell::speller c;
		for(tokenizer::iterator it = tok.begin(); it != tok.end(); ++it){
		    std::cout << *it <<" "; 
			if(it->size()>2 and (*it)[0]!='\\' and boost::regex_match(*it, boost::regex("^[a-z]*$") ) ){
				if(c(*it)){
				}else{
					std::string comment; 
					std::list<string> suggestions = c.suggest(*it);
					for(std::list<string>::const_iterator it_suggest= suggestions.begin(); it_suggest!=suggestions.end(); ++it_suggest){
						comment += (*it_suggest) + "\\n"; //string((i!=suggestions.size()-1)?"\\n ":"");
					}
					boost::algorithm::replace_all(corrected, 
						*it, 
						"\\pdfmarkupcomment[author={English dictionary},subject={spellcheck suggestions},color=Red,opacity=1.0,markup=Squiggly]{" + *it + "}{" + comment +"}\n " 
					);
				}
			}
			std::cout<< std::endl;
		}
		os << corrected.c_str();
	}
	ostream& endl(ostream& os){
		return ostream::endl(os);
	}
	ostream& flush(ostream& os){
		return ostream::flush(os);
	}
	struct par{
		friend ostream& operator<<(ostream& os, par const&){
			return os<<"\n\n\\par ";
		}
	} par;
	struct noindent{
		friend ostream& operator<<(ostream& os, noindent const&){
			return os<<"\\noindent \n";
		}
	} noindent;
	struct newpage{
		friend ostream& operator<<(ostream& os, newpage const&){
			return os<<"\\newpage\n";
		}
	} newpage;
	template<class Command>
	struct nullary{
//		friend ostream& operator<<(ostream& os, Command const&); //{return os<<"\\"<<Command::name()<<"\n";}
	};
	template<class Command>
	struct unary{
		string code_;
		string postscript_;
		unary(string code) : code_(code){}
		friend ostream& operator<<(ostream& os, Command const& c){
			return os<<"\\"<<Command::name()<<"{"<<c.code_<<"} " << c.postscript_;
		}
	};
	struct maketitle : nullary<maketitle>{
		static string name(){return "maketitle";}
	} maketitle;
	struct bibliography : unary<bibliography>{
		bibliography(string bibfile) : unary<bibliography>(bibfile){
			//assert(boost::filesystem::exists(bibfile+".bib")); //need to link to boostfileystem
			postscript_ = "\\attachfile[appearance=false, print=false, subject=Bibliography, description=BibTeX format, mimetype=text/plain]{" + bibfile + ".bib}";
		}
		static string name(){return "bibliography";}
	};
	struct bibliographystyle : unary<bibliographystyle>{ 
		bibliographystyle(string style /*eg. unsrtnat*/) : unary<bibliographystyle>(style){}
		static string name(){return "bibliographystyle";}
	};
	struct ref : unary<ref>{ // ref def
		ref(std::string const& s) : unary<ref>(s){}
		ref(environment const* ptr) : unary<ref>(boost::lexical_cast<string>(ptr)){}
		static string name(){return "ref";}
	};
	template<class Command>
	ostream& operator<<(ostream& os, nullary<Command> const&){return os<<"~\\"<<Command::name()<<"\n";} // ~ to avoid annoying error: ! LaTeX Error: There's no line here to end.
	ostream& operator<<(ostream& os, nullary<class maketitle> const&){
		assert(os.title!="");
		return os<<"\\"<<maketitle::name()<<"\n"; 
	}
	struct title{
		std::string title_;
		std::string author_;
		title(
			std::string const& t, 
			std::string const& a
		) : title_(t), author_(a){}
		friend ostream& operator<<(ostream& os, title const& t){
			os.title = t.title_;
			os.author = t.author_;
			os << maketitle;
			return os;
		}
	};
	struct newline : nullary<newline>{
		static string name(){return "newline";} 
	} newline;
	struct math{
		string code_;
		template<class T>
		math(T* tp) : code_(latex::name[(void*)tp]){}
		math(const char* code)   : code_(code){if(code_==" ") code_="\\quad";}
		math(char const code)    : code_(boost::lexical_cast<string>(code)){if(code_==" ") code_="\\:";} //other options: http://chenfuture.wordpress.com/2008/03/22/math-spacing-and-length-units/
		math(string const& code) : code_(code){}
		math(int code) : code_(boost::lexical_cast<string>(code)){}
		template<class Unit>
		math(boost::units::quantity<Unit> const& q) : code_("0"){
			if(q.value()==0){return;}
			std::ostringstream oss;
			oss << boost::format("%1$1.3d") % q.value();
			code_ = 
				"{"
				"\\href{http://www.wolframalpha.com/input/?i=" + oss.str() + "*(" + name_string(Unit()) + ")}\n"
				+ "{" + 
				math(q.value()).code_ + "~" /*~\\cdot*/ + latex_string(Unit())
				+"}"
				"}"
			;
		}
		math(double const& d){
			std::ostringstream oss;
			oss << boost::format("%1$1.3d") % d ; // << "\\ddots"; //"{\\color{gray}{'}}";
			code_ = oss.str();
			using namespace boost;
			code_ = regex_replace(
				code_,
				regex(
					"e\\+*(-*)0*(\\d{1,})", 
					boost::regex::icase|boost::regex::perl
				), 
				//"{\\\\color{gray}'}"
				"{\\\\scriptstyle \\\\cdot {10}^{$1$2}}"
			);
			code_ = regex_replace(
				code_,
				regex(
					"\\+0{1,}(\\d{1,})", 
					boost::regex::icase|boost::regex::perl
				), 
				"$1"
			);
		}
		math(std::complex<double> const& c){
			{
				std::ostringstream oss; oss << boost::format("%1$1.3d") % c.real();
				code_ = oss.str();
			}{
				if(c.imag()==0){
					code_ += "_{ \\color{gray}{+ \\mathrm{\\imath} 0}}";
				}else{
					std::ostringstream oss; oss << boost::format("%1$1.3d") % c.imag();
					code_ += " + \\mathrm{\\imath} " + oss.str();
				}
			}
		}
		friend ostream& operator<<(ostream& os, math const& self){return os<<self.code();}
		math operator()(math const& other) const{
			return math(this->code_ + "("+ other.code_ +")");
		}
		math operator=(math const& other) const{ //maybe has to be operator==
			return math( this->code_ + " = " + other.code_);
		}
		math operator|(math const& other) const{
			return math( "\\left." + this->code_ + "\\right|_{" + other.code_ + "}");
		}
		math operator,(math const& other) const{
			return math( this->code_ + " , " + other.code_);
		}
		math operator[](string const& subname){
			return math( "{"+this->code_ + "}_{\\rm{"+subname+"}}");
		}
		math operator[](int subindex){
			return math("{"+this->code_+"}_{"+lexical_cast<string>(subindex)+"}");
		}
		string /*NO &*/ code() const{return "\\ensuremath{"+code_+"}";}
		friend math operator<(math const& self, math const& other){
			return math(self.code_ + " < " + other.code_);
		}
		//friend math operator+(math const& sum1, math const& sum2){
		//	return math("{"+sum1.code_+"}+{"+sum2.code_+"}");
		//}
		friend math operator^(math const& base, math const& exponent){
			return math("{"+base.code_+"}^{"+exponent.code_+"}");
		}
		friend math sqrt(math const& base){
			return math("\\sqrt{"+base.code_+"}");
		}
		template<long N>
		friend math power(math const& base){
			return math("{("+base.code_+")}^{"+boost::lexical_cast<string>(N)+"}");
		}
	};
	template<long N>
	math root(math const& base){
		return math("\\sqrt["+lexical_cast<string>(N)+"]{"+base.code_+"}");
	}
	math parenthesis(math const& contents){
		return math("{\\left("+contents.code_+"\\right)}");
	}
	struct substraction : math{
		substraction(string s) : math(s){}
	};
	struct addition : math{
		addition(string s) : math(s){}
	};
	substraction operator-(math const& sub1, math const& sub2){
		return substraction(sub1.code_ + "-" + sub2.code_);
	}
	addition operator+(math const& sum1, math const& sum2){
		return addition(sum1.code_ + "+" + sum2.code_);
	}
	struct number : math{
		number(int const& i) : math(boost::lexical_cast<string>(i)){}
		number(double d) : math(lexical_cast<string>(d)){}
	};
	math operator-(math const& m){
		return math("-"+m.code_);
	}
	math exp(math const& exponent){
		return math("\\exp("+exponent.code_+")");
	}
	template<>
	math root<2>(math const& base){
		return math("\\sqrt{"+base.code_+"}");
	}
	struct product : math{
		product(math const& m) : math(m){}
		math operator^(math const& exponent) const{return math("("+code_+")")^exponent;}
	};
	product operator*(math const& factor1, substraction const& factor2){
		return math("{"+factor1.code_+"}{"+parenthesis(factor2).code_+"}"); //assumme objects multiply like numbers, no symbol for product
	}
	product operator*(addition const& factor1, math const& factor2){
		return product(parenthesis(factor1).code_+"{"+factor2.code_+"}");
	}
	product operator*(math const& factor1, math const& factor2){
		return math("{"+factor1.code_+"}{"+factor2.code_+"}"); //assumme objects multiply like numbers, no symbol for product
	}
	product operator*(number const& factor1, number const& factor2){
		return math("{"+factor1.code_+"}\\cdot{"+factor2.code_+"}");
	}
	struct sum : math{
		sum(math const& m) : math(m){}
		friend math operator*(sum const& s, math const& m){
			return math("("+s.code_+"){"+m.code_+"}");
		}
	};
	struct division : math{
		division(math const& m) : math(m){}
		math operator^(math const& exponent) const{return math("("+code_+")")^exponent;}
	};
	division operator/(math const& factor1, math const& factor2){
		return math("\\frac{"+factor1.code_+"}{"+factor2.code_+"}"); //assumme objects multiply like numbers
	}

	//friend 
	ostream& operator<<(ostream& os, double const& d){
		(ostream::base&)(os) << math(d).code_; return os;
		//((base&)(os))<< d; return os;
	}
	template<class Unit> //friend 
	ostream& operator<<(ostream& os, boost::units::quantity<Unit> const& q){
		(ostream::base&)(os) << math(q).code(); return os;
	}
	template<class Dimension, class System>
	ostream& operator<<(ostream& os,boost::units::unit<Dimension, System> const& u){
		(ostream::base&)(os) << "\\ensuremath{" << u << "} "; return os;
	}
	template<class Figure>
	struct figure_category : ostream{
		string caption;
		bool asterisk;
		figure_category() : asterisk(false){}
		friend ostream& operator<<(ostream& os, Figure const& f){
			os.preamble()<< f.preamble();
			os << "\n\\begin{" << Figure::name() << (f.asterisk?"*":"") << "}\n"
				 << f.str() << "\n";
			if(not f.caption.empty()) os <<"\\caption{"<<f.caption<<"}\n";
			os << "\\end{" << Figure::name()   << (f.asterisk?"*":"") << "}\n";
			return os;
		}
	};
	struct figure : figure_category<figure>{
		figure& operator*(){asterisk=true; return *this;}
		static string name(){return "figure";}
	};
	template<class Command>
	struct command_category{
		friend ostream& operator<<(ostream& os, Command const& c){
			os.preamble()<< c.preamble();
			os << "\\" << Command::name() << "{"
				 << c.str() << "\n";
			os << "}\n";
			return os;
		}
	};
	struct marginnote : ostream, command_category<marginnote>{
		marginnote(){}
		marginnote(string contents){ (*this)<<contents;}
		static string name(){return "marginnote";}
		protected:
		using ostream::str;
		friend ostream& operator<<(ostream& os, marginnote const& c);
	};
	struct environment {//: ostream{
	};
	template<class Environment>
	struct environment_category : environment{
		//virtual string preamble() const{return "";}
		friend ostream& operator<<(ostream& os, Environment const& f){
			os.preamble()<< f.preamble();
			os << "\n"
				"\\begin{" << Environment::name() << "}\n" << 
					f.str() << "\n" << 
					((Environment::name()!="lstlisting")?("\\label{" + boost::lexical_cast<string>(&f) + "}\n"):("")) <<
				"\\end{" << Environment::name() << "}\n";
			return os;
		}
		/*
		friend ostream& operator<<(ostream& os, Environment& f){
			os.preamble()<< f.preamble();
			os << "\n\\begin{" << Environment::name() << "}\n"
				 << f.str() << "\n"
				<< "\\label{" << &f << "}\n";
			os << "\\end{" << Environment::name() << "}\n";
			return os;
		}*/
	};
	struct abstract: ostream, environment_category<abstract>{
		abstract(){}
		abstract(string contents){ (*this)<<contents;}
		static string name(){return "abstract";}
		using ostream::str;
	};
	struct equation : ostream, environment_category<equation>{
		//equation(string code){ (*this) << code;}
		equation(math const& m){ (*this) << m;}
		static string name(){return "equation";}
		using ostream::str;
	};
	namespace tufte{
		struct fullwidth : 
			ostream, 
			environment_category<fullwidth>{
			fullwidth(){}
			fullwidth(string contents){ (*this) << contents;}
			static string name(){return "fullwidth";}
			friend struct environment_category<fullwidth>;
			using ostream::str;
		};
	}
	struct tikzpicture;
	struct tikz_object{
		virtual tikzpicture& operator>>(tikzpicture&) const=0;
	};
	struct tikzpicture : ostream{
		tikzpicture(){}
		tikzpicture(tikzpicture const& other) :  std::basic_ios<char, std::char_traits<char> >(), ostream(other.str()){}
		static string name(){return "tikzpicture";}
		//tikzpicture& operator<<(tikz_object const& t);//{assert(0); return *this;}
		friend tikzpicture& operator<<(tikzpicture& self, tikz_object const& t){
			t>>self;
			return self;
		}
		friend ostream& operator<<(ostream& os, tikzpicture const& tp){
			os.temp_files_.insert(tp.temp_files_.begin(), tp.temp_files_.end());
			os.preamble()<< tp.preamble();
			os << "\\begin{" << tikzpicture::name() << "}\n"
				 << tp.str() << "\n";
			os << "\\end{" << tikzpicture::name() << "}\n";
			return os;
		}
	};
	namespace tikz{
		typedef tikzpicture picture;
	}
	tikzpicture& operator<<(tikzpicture& tp, boost::multi_array<bool, 2> const& f){
		tp << "\\draw[help lines] ("<< -0.5 <<", "<< -0.5 <<") grid (" << f.shape()[0]-0.5 <<", " << f.shape()[1]-0.5 <<");";
		for(unsigned i = 0; i!=f.shape()[0]; ++i){
			for(unsigned j=0; j!=f.shape()[1]; ++j){
				if(f[i][j]==true){
					tp  << "\\draw[very thick, ->] (" << i+0. <<", "<<j-0.25 <<")--("<<i+0.<<", "<<j+0.25<<");";
				}else{
					tp  << "\\draw[very thick, <-] (" << i+0. <<", "<<j-0.25 <<")--("<<i+0.<<", "<<j+0.25<<");";
				}
			}
		}
		return tp;
	}
	struct marginfigure : figure_category<marginfigure>{
		static string name(){return "marginfigure";}
	};
	template<class CRTP>
	struct section_category{
		string title_;
		bool asterisk_;
		section_category(string title) : title_(title), asterisk_(false){}
		CRTP& operator*(){asterisk_=true; return static_cast<CRTP&>(*this);}
		friend ostream& operator<<(ostream& os, CRTP const& self){
			os<<string("\n\n\\"+CRTP::name()+(self.asterisk_?string("*"):string(""))+"{");
			os<<self.title_;
			return os<<string("}\n");
		}
	};
	struct section : public section_category<section>{
		explicit section(string title) : section_category<section>(title){}
		static string name(){return "section";}
	};
	struct subsection : section_category<subsection>{
		explicit subsection(string title) : section_category<subsection>(title){}
		static string name(){return "subsection";}
	};
	struct subsubsection : section_category<subsubsection>{ //not defined in tufte latex
		subsubsection(string title) : section_category<subsubsection>(title){}
		static string name(){return "subsubsection";}
	};
	struct newthought : section_category<newthought>{  // defined in tufte latex
		newthought(string title) : section_category<newthought>(title){}
		static string name(){return "newthought";} // needs a freaking double new-line before 
	};
	/// Automatic generation of (LaTeX) PGFplot's
	namespace listings{
		struct lstlisting : ostream, environment_category<lstlisting>{
			lstlisting(lstlisting const& other) : std::basic_ios<char, std::char_traits<char> >(), ostream(other.str()){}
			lstlisting(string contents){(*this) << contents;}
			lstlisting(char const contents[]){(*this) << contents;}
			static string name(){return "lstlisting";}
			using ostream::str;
		};
	}
	#define LATEX_LISTING_CODE(code) listings::lstlisting(#code); code
	namespace pgfplots{
		using boost::named;
		struct pair : std::pair<double, double>{
			pair(std::pair<double, double> const& p) : std::pair<double, double>(p){}
			pair(double const& d1, double const& d2) : std::pair<double, double>(d1, d2){}
			template<class Unit1, class Unit2> struct units;
		};
		template<class Unit1, class Unit2> 
		struct pair::units : pair{
			units(
				boost::units::quantity<Unit1> const& q1, 
				boost::units::quantity<Unit2> const& q2
			) : 
			pair(q1.value(), q2.value()){}
			template<class QA, class QB>
			units(
				//boost::units::quantity<UnitA> 
				QA const& qa, 
				//boost::units::quantity<UnitB> 
				QB const& qb
			)   :
				pair(
					boost::units::quantity<Unit1>(qa).value(), 
					boost::units::quantity<Unit2>(qb).value()
			){}
		};
		struct triple : boost::tuples::tuple<double, double, double>{
			triple(boost::tuples::tuple<double, double, double> const& t) : boost::tuples::tuple<double, double, double>(t){}
			triple(double const& d1, double const& d2, double const& d3) : boost::tuples::tuple<double, double, double>(d1, d2, d3){}
			template<class UX, class UY, class UZ> class units;
		};
		template<class UX, class UY, class UZ>
		struct triple::units : triple{
			units(
				boost::units::quantity<UX> const& q1, 
				boost::units::quantity<UY> const& q2, 
				boost::units::quantity<UZ> const& q3
			) : triple(
				q1.value(), 
				q2.value(), 
				q3.value()
			){} 
		};
		using std::vector; 
		typedef std::map<double, double> map;
		class axis_base;
		class axis;
		//class semilogxaxis; use "xmode = log, ymode = log" options to simplify
		struct plot : std::ostringstream{
			plot(){}
			plot(plot const& other) : 
				std::basic_ios<char, std::char_traits<char> >(), //solve warning in g++ 4.4.3 -Wextra
				std::ostringstream(other.str()){}
			virtual void operator>>(axis& a) const=0;
			virtual ~plot(){}
			template<class UnitX, class UnitY>
			class units;
		};
		struct axis_base : std::ostringstream, public tikz_object{
			//using std::ostringstream::operator<<;
			std::set<path> temp_files_;
			string options_;
			string coordinates_as_table_preamble_;
			axis_base(string opt="") : options_(opt){}
			axis_base& addlegendentry(string const& s){(*this) << "\\addlegendentry{" << s << "}\n"; return *this;}
			virtual tikzpicture& operator>>(tikzpicture& tp) const{
				//tp.temp_files_.insert(a.temp_files_.begin(), a.temp_files_.end());
				tp.usepackage("pgfplots");
				tp.preamble()<< "\\usepackage{pgfplots}\n\\usepgfplotslibrary{units}\n\\pgfplotsset{unit code/.code 2 args={{#1#2}}, unit marking pre={(}, unit marking post = {)} }\n"; // unit markings=parenthesis}\n";
				//os<<"\\tikzstyle{background rectangle}=[fill=white,opacity=0.1]\n"; //yellow
				tp<<
					"\\begin{axis}["<<this->options_<<"]\n"
						<<this->str()<<"\n"
					"\\end{axis}\n"
				;
				tp.preamble()<< "\\usetikzlibrary{backgrounds}\n";
				tp.preamble()<< "\\usetikzlibrary{patterns}\n";
				//tp.preamble()<< "\\usepgfplotslibrary{clickable}\n"; //needs insdljs.sty (AcroTeX)
				tp.preamble()<< "\\usepgfmodule{decorations}\n";
				return tp;
			}
			template<class UX, class UY>
			class units;
		};
		template<class UX, class UY>
		struct axis_base::units : public axis_base{
			units(string options="") : axis_base(options){}
		};
		template<class AxisT>
		struct axis_category : /*novirtual*/ axis_base{
			protected:
			axis_category(string options = "") : axis_base(options){}
			public:
			string code() const{
				return 
					"   \\begin{" + AxisT::name() + string("}[") +options_ + string("]\n")
					+		str() + string("\n"
					"   \\end{")  + AxisT::name() + string("}\n");
			}
			AxisT const& save(path p) const{
				clog << AxisT::name()<<"::save "<<p.string()<< endl;
				boost::filesystem::ofstream ofs(p);
				ofs << 
					"   \\begin{"+ AxisT::name() +"}["<<options_<<"]\n"
							<<str()<<"\n"
					"   \\end{"  + AxisT::name() +"}\n"
				;
				return static_cast<AxisT const&>(*this);
			}
			//friend ostream& operator<<(ostream& os, AxisT const& a){
			// bm1
			friend tikzpicture& operator<<(tikzpicture& os, AxisT const& a){ //axises can be put in a tikzpicture only
				os.temp_files_.insert(a.temp_files_.begin(), a.temp_files_.end());
				os.usepackage("pgfplots");
				os.preamble()<< "\\usepackage{pgfplots}\n\\usepgfplotslibrary{units}\n\\pgfplotsset{unit code/.code 2 args={{#1#2}}, unit marking pre={(}, unit marking post = {)} }\n"; // unit markings=parenthesis}\n";
				//os<<"\\tikzstyle{background rectangle}=[fill=white,opacity=0.1]\n"; //yellow
				os<<
					"\\begin{"+ AxisT::name()+"}["<<a.options_<<"]\n"
						<<a.str()<<"\n"
					"\\end{"+ AxisT::name() +"}\n"
				;
				os.preamble()<< "\\usetikzlibrary{backgrounds}\n";
				os.preamble()<< "\\usetikzlibrary{patterns}\n";
				//os.preamble()<< "\\usepgfplotslibrary{clickable}\n";
				os.preamble()<< "\\usepgfmodule{decorations}\n";
				return os;
			}
			template<class T>
			AxisT& operator<<(boost::named<T> const& c){
				static_cast<AxisT&>(*this) << "\\addlegendentry{"<<c.name()<<"}\n";
				c >> static_cast<AxisT&>(*this);
				return static_cast<AxisT&>(*this);
			}
			template<class UX, class UY>
			struct units;  // axis_category::units decl
		};
		class axis;
		class coordinates;
		class file; // pgfplots::file decl
		struct axis : 
			axis_category<axis>{
			struct options;  // axis::options decl
			static std::string name(){return "axis";}
			axis(string options = "") : axis_category<axis>(options){coordinates_as_table_preamble_ = /*"\\#"+*/ options +"\n";}// + options;}
			axis(options const& o);
			axis& operator()(std::map<string, coordinates> const& m);
			axis& operator<<(plot const& c){
				c >> *this; 
				return *this;
			}
			template<class T>
			axis& operator<<(boost::named<T> const& c){ //axis::operator<<
				(*this) << "\\addlegendentry{"<<c.name()<<"}\n";
				c >> *this;
				return *this;
			}
			template<class T>
			void operator<<(std::pair<string, T> const& p){
				std::string coordinates_as_table = p.second.str();
				boost::algorithm::replace_all(coordinates_as_table, "\n", "\\n");
				boost::algorithm::replace_all(coordinates_as_table, "(", "");
				boost::algorithm::replace_all(coordinates_as_table, ")", "");
				boost::algorithm::replace_all(coordinates_as_table, "%", "");
				boost::algorithm::replace_all(coordinates_as_table, ",", "\\t");
				std::string subject = p.first;
				p.second.node_at_end_ = "AAA";
				(*this) << p.second;
				(*this) 
					<< "\\addlegendentry{"
					//<< "\\pdfmarkupcomment[author={author},subject={" << subject
					//<< "},color=red,opacity=0.01, markup=underline]{" << p.first << "}{" << coordinates_as_table << "} "
					<< p.first << " " 
					<< "\\pdfmarginpar[Note, Open=false, CA=0.05, Subject={" << subject <<" " //<< "}, Caption={"
					<< "}]{"<< coordinates_as_table << " }"
					<< "}";
			}
			template<class UnitX, class UnitY> struct units; // axis::units decl
		};
		struct axis::options : protected string, public std::map<string, string>{ // axis::options def
			std::map<double, string> ytick;
			std::map<double, string> xtick;
			options(){}
			options(string const& s) : string(s){}
			//options(char const* const& c) : string(c){}
			using std::map<string, string>::operator[];
			std::string code() const{
				string ret;
				ret += (string const&)(*this) + ", ";
				for(std::map<string, string>::const_iterator it = std::map<string, string>::begin(); it!= std::map<string, string>::end(); ++it){
					ret += it->first + " = " + it->second + ", ";
				}
				if(not xtick.empty()){
					string xtick_code; string xticklabels_code;
					for(std::map<double, string>::const_iterator it = xtick.begin(); it!=xtick.end(); ++it){
						if(it!=xtick.begin()){
							xtick_code+=", ";
							xticklabels_code+=", ";
						}
						xtick_code+=boost::lexical_cast<string>(it->first);
						xticklabels_code+="{" + it->second + "}";
					}
					ret+= "xtick = {"+xtick_code +"}, xticklabels = {"+ xticklabels_code +"}, ";
				}
				if(not ytick.empty()){
					string ytick_code; string yticklabels_code;
					for(std::map<double, string>::const_iterator it = ytick.begin(); it!=ytick.end(); ++it){
						if(it!=ytick.begin()){
							ytick_code+=", ";
							yticklabels_code+=", ";
						}
						ytick_code+=boost::lexical_cast<string>(it->first);
						yticklabels_code+="{" + it->second + "}";
					}
					ret+= "ytick = {"+ytick_code +"}, yticklabels = {"+ yticklabels_code +"}, ";
				}
				return ret;
			}
			options& operator|=(options const& other){
				string::operator+=(", ");
				string::operator+=(other);
				for(std::map<string, string>::const_iterator it = other.std::map<string, string>::begin(); it!= other.std::map<string, string>::end(); ++it){
					std::map<string, string>::insert(*it);
				}
				return *this;
			}
			friend options operator|(options const& op1, options const& op2){
				options ret(op1); return ret|=(op2);
			}
			friend options operator|(options const& op1, char const* const& op2){
				options ret(op1); return ret|=(options(op2));
			}
		};
		axis::axis(options const& o) : axis_category<axis>(o.code()){}
		static axis::options const no_markers("no markers");
		/// Semi logarithmic x axis  : use xmode = log
		template<class UX, class UY>
		struct plot::units : std::ostringstream{
			string options_;
			string postscript_;
			units(units const& other) :
				std::basic_ios<char, std::char_traits<char> >(), //solves warning g++ 4 -Wextra
				std::ostringstream(other.str()),
				options_(other.options_),
				postscript_(other.postscript_)
			{}
			units(string options="", string postscript="") : 
				options_(options), 
				postscript_(postscript)
			{
				//this->fill(' '); 
				this->precision(15); //don't use lower precision since it will present rugged texture in graphs with high mean mean
			}
			virtual void operator>>(axis_base::units<UX, UY>& a) const=0;
		};
		struct file : virtual plot{ // pgfplots::file def
			public:
			boost::filesystem::path p_;
			std::string options_;
			file(boost::filesystem::path const& p) :p_(p){}
			file(std::string options, boost::filesystem::path const& p) : p_(p), options_(options){}
			/*virtual*/ 
			void operator>>(axis& ax) const{
				ax << "\\addplot+[" << options_ <<"] file {" << p_.string() <<"} node[]{ \\attachfile[color=yellow,icon=Graph,print=false,zoom=false]{" << p_.string() << "} };";  
				return;
			}
		};
		struct coordinates : virtual plot{                                     // pgfplots::coordinates def
			string options_;
			string postscript_;
			std::ostringstream text_table_;
			coordinates(coordinates const& other) : 
				std::basic_ios<char, std::char_traits<char> >(), //solves warning in g++ 4.4.3 -Wextra
				plot(other), 
				options_(other.options_), 
				postscript_(other.postscript_), 
				text_table_(other.text_table_.str()){}
			coordinates& operator=(coordinates const&){
				assert(0);
			}
			coordinates(string s="", string p="") : options_(s), postscript_(p){
				text_table_.fill (' '); 
				text_table_.precision(15);
			} //e.g. coordinates("", "\\closedcycle");
			coordinates& operator<<(pair const& p){
				text_table_ << p.first <<"	" <<p.second<<" \n";
				if((boost::math::isfinite)(p.first) and (boost::math::isfinite)(p.second))
					*this<<"( "<<p.first<<", "<<p.second<<" )\n"; 
				else
					*this << "%( "<<p.first<<", "<<p.second<<" )  %discarted point due to not finite number condition \n"; 
				return *this;
			}
			typedef std::map<double, double> map;
			coordinates& operator()(map const& m){
				for(map::const_iterator it=m.begin(); it!=m.end(); ++it){
					this->operator<<(pair(*it));
				}
				return *this;
			}
			virtual void operator>>(axis& a) const{
				std::string coordinates_as_table = this->str();
				boost::algorithm::replace_all(coordinates_as_table, "\n", "\\n");
				boost::algorithm::replace_all(coordinates_as_table, "(", "");
				boost::algorithm::replace_all(coordinates_as_table, ")", "");
				boost::algorithm::replace_all(coordinates_as_table, "%", "");
				boost::algorithm::replace_all(coordinates_as_table, ",", "\\t");
				a
					<< "\\addplot"
					<< (options_!=""?"+["+options_+"]":string())  
					<< " coordinates { \n"<<this->str()<<"} "
					<< postscript_ //<<" ; \n";
					<<" node{"
					//<<"\\pdfmarginpar[Name=Note, Open=false, CA=0.1, Subject={}, caption={}]{ " << coordinates_as_table << " }"
					<<"}"
					<<"; \n"
				;
			}
			template<class UnitX, class UnitY> struct units; // decl class axis::units
		};
		using boost::numeric::interval;
		using boost::optional;
		template<class UX, class UY> 
		struct axis::units :                                   //  axis::units def
			axis_base::units<UX,UY>{
			struct options : axis::options{                    // axis::options def
				options(string const& s="") : axis::options(s){}
				std::map<quantity<UX>, string> extra_x_tick;
				std::map<quantity<UY>, string> extra_y_tick;
				optional<interval<quantity<UX> > > restrict_x_to_domain;
				std::string code() const{
					//return (string)(*this);}
					//operator std::string() const{
					string ret;
					ret += (string const&)(*this);
					if(ret!="") ret+=", ";
					if(not extra_x_tick.empty()){
						string extra_x_ticks = "extra x ticks = {";
						string extra_x_tick_labels = "extra x tick labels = {";
						for(typename std::map<quantity<UX>, string>::const_iterator it=
								extra_x_tick.begin(); it!=
								extra_x_tick.end(); ++it
						){
							extra_x_ticks += lexical_cast<string>(it->first.value());
							extra_x_tick_labels += lexical_cast<string>(it->second);
							if(boost::next(it)!=extra_x_tick.end()){
								extra_x_ticks += ", ";
								extra_x_tick_labels +=", ";
							}
						}
						extra_x_ticks += "} ";
						extra_x_tick_labels +="} ";
						ret+=extra_x_ticks+", "+extra_x_tick_labels;
					}
					ret+=", ";
					if(not extra_y_tick.empty()){
						string extra_y_ticks = "extra y ticks = {";
						string extra_y_tick_labels = "extra y tick labels = {";
						for(typename std::map<quantity<UY>, string>::const_iterator it=
								extra_y_tick.begin(); it!=
								extra_y_tick.end(); ++it
						){
							extra_y_ticks += lexical_cast<string>(it->first.value());
							extra_y_tick_labels += lexical_cast<string>(it->second);
							if(boost::next(it)!=extra_y_tick.end()){
								extra_y_ticks += ", ";
								extra_y_tick_labels +=", ";
							}
						}
						extra_y_ticks += "} ";
						extra_y_tick_labels +="} ";
						ret+=extra_y_ticks+", "+extra_y_tick_labels;
					}
					if(restrict_x_to_domain) ret+=", restrict x to domain = "+lexical_cast<string>(lower(*restrict_x_to_domain).value())+":"+lexical_cast<string>(upper(*restrict_x_to_domain).value());
					return ret;
				}
			};
			typedef coordinates::units<UX, UY> coordinates_type; //cannot name it "coordinates"
			typedef pair::units<UX, UY> pair_type;
			static std::string name(){return "axis";}
			units(string opts) //this can benefit from delegating constructors
				:
				axis_base::units<UX, UY>(
					string(latex_string(UX())!=""? //handle dimensionless units
						"x unit = {"
							"\\href{http://www.wolframalpha.com/input/?i=(" + name_string(UX()) + ")}{"
								+ latex_string(UX()) + "}}, ":"")
								+ string(latex_string(UY())!=""?
					"y unit = {" 
					"\\href{http://www.wolframalpha.com/input/?i=(" + name_string(UY()) + ")}{"
					+ latex_string(UY()) + "}}, ":"")+
				"xlabel = {" + boost::units::name<typename UX::dimension_type>() + "}, "
				"ylabel = {" + boost::units::name<typename UY::dimension_type>() + "}  " 
				+ ((options(opts).code().empty()?"":", ") + options(opts).code())
			){}
			units(options opt = options()) 
				: 
				axis_base::units<UX, UY>(
					string(latex_string(UX())!=""? //handle dimensionless units
						"x unit = {"
							"\\href{http://www.wolframalpha.com/input/?i=(" + name_string(UX()) + ")}{"
								+ latex_string(UX()) + "}}, ":"")
								+ string(latex_string(UY())!=""?
					"y unit = {" 
					"\\href{http://www.wolframalpha.com/input/?i=(" + name_string(UY()) + ")}{"
					+ latex_string(UY()) + "}}, ":"")+
				"xlabel = {" + boost::units::name<typename UX::dimension_type>() + "}, "
				"ylabel = {" + boost::units::name<typename UY::dimension_type>() + "}  " 
				+ ((opt.code().empty()?"":", ") + opt.code())
			){}
			units& operator<<(plot::units<UX, UY> const& c){
				c >> static_cast<units&>(*this); return static_cast<units&>(*this);
			}
			template<class T>
			units& operator<<(boost::named<T> const& c){ //axis::units::operator<<
				(*this) << "\\addlegendentry{"<<c.name()<<"}\n";
				c >> *this;
				return *this;
			}
			void save(path p) const{
				boost::filesystem::ofstream ofs(p);
				ofs<< "%\\usepackage{pgfplots}\n";
				ofs << 
					"\\begin{tikzpicture}\n"
					"   \\begin{axis}["<<options_<<"]\n"
							<< this->str()<<"\n"
					"   \\end{axis}\n"
					"\\end{tikzpicture}\n";
				return; // static_cast<AxisT const&>(*this);
			}
			template<class T>
			void operator<<(std::pair<char const*, T> const& p){
				(*this)<< std::make_pair(std::string(p.first), p.second);
			}
			template<class T>
			void operator<<(std::pair<string, T> const& p){
				std::string coordinates_as_table = p.second.str();
				boost::algorithm::replace_all(coordinates_as_table, "\n", "\\n");
				boost::algorithm::replace_all(coordinates_as_table, "(", "");
				boost::algorithm::replace_all(coordinates_as_table, ")", "");
				boost::algorithm::replace_all(coordinates_as_table, "%", "");
				boost::algorithm::replace_all(coordinates_as_table, ",", "\\t");
				std::string subject = p.first;
				(*this) << p.second;
				(*this) 
					<< "\\addlegendentry{"
					<<"\\hypertarget{" << &p.second << "}{ }"
					//<< "\\pdfmarkupcomment[author={Donald Duck},subject={" << subject << " "
					//<< boost::units::name<typename UX::dimension_type>()<< " ["<< UX() <<"], "
					//<< boost::units::name<typename UY::dimension_type>()<< " ["<< UY() <<"]  "
					//<< "},color=red,opacity=0.1, markup=Underline]{" << p.first << "}{" << coordinates_as_table << "} "
					<< p.first << " " 
					<< "\\pdfmarginpar[Note, Open=false, CA=0.05, Subject={" << subject <<" " //<< "}, Caption={"
					<< boost::units::name<typename UX::dimension_type>()<< " ["<< UX() <<"], "
					<< boost::units::name<typename UY::dimension_type>()<< " ["<< UY() <<"]  "
					<< "}]{"<< coordinates_as_table << " }"
					<< "}\n"
				;
			}
			/*
			friend ostream& operator<<(ostream& os, units const& a){
				os.temp_files_.insert(a.temp_files_.begin(), a.temp_files_.end());
				os.usepackage("pgfplots");
				os.preamble()<< "\\usepackage{pgfplots}\n\\usepgfplotslibrary{units}\n\\pgfplotsset{unit code/.code 2 args={{#1#2}}, unit marking pre={(}, unit marking post = {)} }\n"; //unit markings=parenthesis}\n";
				os<<"\\tikzstyle{background rectangle}=[fill=white,opacity=0.1]\n"; //yellow
				os<<"	\\begin{"+ units::name()+"}["<<a.options_<<"]\n"
				  <<a.str()<<"\n";
				os<<"	\\end{"+ units::name() +"}      \n";
				os.preamble()<< "\\usetikzlibrary{backgrounds}\n";
				os.preamble()<< "\\usetikzlibrary{patterns}\n";
				os.preamble()<< "\\usepgfplotslibrary{clickable}\n";
				os.preamble()<< "\\usepgfmodule{decorations}\n";
				return os;
			}*/
		};
		/*
		template<class UX, class UY> struct semilogxaxis::units : axis_base::units<UX, UY>{
			//public std::ostringstream{
			typedef coordinates::units<UX, UY> coordinates_type;
			//std::set<path> temp_files_;
			//string options_;
			static std::string name(){return "semilogxaxis";}
			units(string s = "") : axis_base::units<UX,UY>(s){}
			units& operator<<(plot::units<UX, UY> const& c){
				c >> static_cast<units&>(*this); return static_cast<units&>(*this);
			}
			friend ostream& operator<<(ostream& os, units const& a){
				os.temp_files_.insert(a.temp_files_.begin(), a.temp_files_.end());
				os.usepackage("pgfplots");
				os.preamble()<< "\\usepgfplotslibrary{units}\n\\pgfplotsset{unit code/.code 2 args={{#1#2}}, unit marking pre={(}, unit m