#include "/usr/local/Wolfram/Mathematica/7.0/SystemFiles/Links/MathLink/DeveloperKit/Linux/CompilerAdditions/mathlink.h"
#include<iostream>
#include<cassert>
#include<stdexcept>

// supported types
#include<complex>
#include<string>
#include<vector>

using std::clog; 
using std::endl;

namespace mathematica{
	class environment{
		public:
		environment(char* p=0){
			env_=MLInitialize(0);
			assert(env_!=0);
		}
		virtual ~environment(){
			MLDeinitialize(env_);
		}
		private:
		MLEnvironment env_;
	};
	class link{
		public:
		link(){
 	 		int argc = 4; 
			char const* argv[5] = {"-linkname", "math -mathlink", "-linkmode", "launch"};			
			lp_=MLOpen(argc, const_cast<char**>(argv));
			assert(lp_!=0);
		}
		virtual ~link(){MLClose(lp_);}
		
		// basic vanilla interface
		int  put_function(std::string const& name, int const& argc){return MLPutFunction(lp_, name.c_str(), argc);}
		int  put_double(double const& x){return MLPutDouble(lp_, x);}
		int  put_integer(int const& i){return MLPutInteger(lp_,i);}
		int  put_real64_list(double* a, int n){return MLPutReal64List(lp_, a, n);}
		int  put_string(const char* s){return MLPutString(lp_,s);}
		int  put_symbol(const char* s){return MLPutSymbol(lp_,s);}

		int  get_function(const char** cp, int* np){return MLGetFunction(lp_, cp, np);}
		int  get_double(double* dp){return MLGetDouble(lp_, dp);}
		int  get_integer(int* ip){return MLGetInteger(lp_,ip);}
		int  get_real64_list(double** a, int* n){return MLGetReal64List(lp_, a, n);} //remember to release_real64_list
		int  get_string(const char** sp){return MLGetString(lp_,sp);}	//remember to release_string
		int  get_symbol(const char** sp){return MLGetSymbol(lp_,sp);}	//remember to release_symbol
		int  get_type(){return MLGetType(lp_);}
		
		void release_symbol(const char* s){MLReleaseSymbol(lp_,s);}
		void release_real64_list(double* dp, int n){MLReleaseReal64List(lp_,dp, n);}

		int  end_packet(){return MLEndPacket(lp_);}
		int  next_packet(){return MLNextPacket(lp_);}
		int  new_packet(){return MLNewPacket(lp_);}

		int  test_head(std::string const& name, int* np){return MLTestHead(lp_,name.c_str(), np);}
		
		int  flush(){return MLFlush(lp_);}
		int  error(){return MLError(lp_);}
		
		// safe vanilla interface (get rid of char** interface);
		int get_function(std::string* sp, int* np){
			const char* cpp;
			int ret=get_function(&cpp, np);
			if(ret!=0){*sp=std::string(cpp);}else{*sp="";}
			release_symbol(cpp);
			return ret;
		}
		int get_string(std::string* sp){
			const char* cpp;
			int ret=get_string(&cpp);
			if(ret!=0){*sp=std::string(cpp);}else{*sp="";}
			release_symbol(cpp);
			return ret;
		}
		int get_symbol(std::string* sp){
			const char* cpp;
			int ret=get_symbol(&cpp);
			if(ret!=0){*sp=std::string(cpp);}else{*sp="";}
			release_symbol(cpp);
			return ret;
		}
		int put_string(std::string const& s){
			return put_string(s.c_str());
		}
		// extended vanilla interface (add complex support)
		int put_complex_double(std::complex<double> const& c){
			put_function("Complex", 2);
			put_double(c.real());
			return put_double(c.imag());
		}
		int put_real64_list(std::vector<double> const& v){return put_real64_list(const_cast<double*>(&v[0]), v.size());}
		int get_real64_list(std::vector<double>* v){
			double* dp;
			int n=0;
			if(get_real64_list(&dp, &n)){
				v->resize(n);
				std::copy(dp, dp+n, v->begin());
				return 1;
			}
			release_real64_list(dp,n);
			return 0;
		}
		int get_complex_double(std::complex<double>* cp){
			int n=-1;
			std::string f;
			double re=-1;
			if(get_type()==MLTKFUNC and test_head("Complex", &n) and n==2){
				double im=-1;
				if(get_double(&re) and get_double(&im)){
					*cp=std::complex<double>(re,im);						// don't do std::complex<double>(get<double>(), get<double>()); order undefined!!
					return 1;
				}
				return 0;				
			}
			if(get_double(&re)){
				*cp=re;
				return 1;
			}
			return 0;
  		}
		
		// overloaded interface (also easies the templatized version)
		int put(double const& x){return put_double(x);}
		int put(std::complex<double> const c){return put_complex_double(c);}
		int put(int const& i){return put_integer(i);}
		
		int get(double* dp){return get_double(dp);}
		int get(std::complex<double>* cp){return get_complex_double(cp);}
		int get(int* ip){return get_integer(ip);}
		template<typename T>
		int get(std::vector<T>* vp){return get_list(vp);}
		
		// support of STL types
		template<typename T1, typename T2>
		int put(std::pair<T1, T2> const& p){
			if(put_function("List",2)){
				put(p.first);
				put(p.second);
				return 1;
			}
			return 0;
		}
		
		// autogenerated pointer free interface
		template<typename T>
		int get(T& t){return get(&t);}
		
		// partially templatize interface
		template<class Container>
		void put_list(Container const& c){
			put_function("List", c.size());
			for(typename Container::const_iterator i=c.begin(); i!=c.end(); ++i){
				put(*i);
			}
		}
		template<class Container>
		int get_list(Container* c){
			std::string s;
			int n=-1;
			if(not get_function(&s, &n) or s!="List" or n<0) return 0;
			c->clear(); //c->resize(n);
			for(int i=0; i!=n; ++i){
				typename Container::value_type val;
				if(!get(&val)) return 0;
				c->push_back(val); //(*c)[i]=val;
			}
			return 1;
		}
		template<typename T>
		int get_list(boost::multi_array<T,1>* maP){
			std::string s;
			int n=-1;
			if(not get_function(&s, &n) or s!="List" or n<0) return 0;
			maP->resize(boost::extents[n]);
			for(int i=0; i!=n; ++i){
				typename boost::multi_array<T,1>::value_type val;
				if(!get(&val)) return 0;
				(*maP)[i]=val; //(*c)[i]=val;
			}
			return 1;			
		}
		// totally templatized interface
		template<typename T>
		T get(){
			T t; 
			if(!get(&t)){
				throw std::runtime_error("can not interpret mathematica output as type implied by get<T>");
			}
			return t;
		}
		private:
		class get_return_overload{
			public:
			get_return_overload(link& parent) : parent_(parent){}
			get_return_overload(get_return_overload const&);			//noncopyable
			template<typename T>
			operator T() const{return parent_.get<T>();}
			private:
			link& parent_;
		};
		public:
		get_return_overload get(){return get_return_overload(*this);}
		private:
		MLINK lp_;
	};
}

